인터페이스가 없어도 클래스 기반으로도 프록시를 생성할 수 있다.

클래스 기반 프록시는 해당 클래스에만 적용할 수 있는 반면,
인터페이스 기반 프록시는 해당 인터페이스만 같다면 모두 적용할 수 있다.

클래스 기반 프록시는 다음과 같은 제약이 있다.
 - 부모  클래스의 생성자를 호출하여야 한다.
 - 클래스에 final 키워드가 붙으면 상속이 불가능하다.
 - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.

이론적으로는 모든 객체에 인터페이스를 도입해서 역할과 구현을 나누는것이 좋으나, (역할과 구현을 나누어 매우 편리하게 변경할 수 있음.)
실제로는 구현을 거의 변경할 일이 없어 클래스만 있는 경우가 많다.
 -> 때문에 프록시를 적용할 때 인터페이스와 구체 클래스를 둘다 섞어서 사용한다. 


프록시 팩토리
포인트컷 : 어느 부분에 부가기능을 적용할지 설정. 
어드바이스 : 프록시가 호출하는 부가기능 설정.
어드바이저 : 적용위치(포인트컷)와 부가기능(어드바이스) 을 모두 가지고 있는것.


build.gradle에 implementation 'org.springframework.boot:spring-boot-starter-aop' 를 추가하면
aspectJ 관련 라이브러리를 등록한다. (스프링 부트가 AOP 관련 클래스를 자동으로 스프링 빈에 등록한다.)

=========================================================================================================
※ 프록시 생성기 작동 과정 !!!
1. 생성 : 스프링이 스프링 빈 대상이 되는 객체를 생성함.(@Bean, 컨포넌트 스캔 모두 포함.)
2. 전달 : 만든 객체를 빈저장소(스프링 컨테이너)에 등록하기전에 빈 후처리기에 먼저 전달함.
3. Advisor 빈 조회 : 빈 후처리기(자동 프록시 생성기)는 스프링 컨테이너에서 모든 Advisor 빈을 다 조회한다.
4. 프록시 적용 대상 체크 : 앞서 가져온 Advisor의 포인트컷을 통해 프록시를 적용할 대상들을 모두 체크한다.
  (이때 해당 빈 객체들의 모든 메서드 하나하나를 포인트 컷과 매칭해보고 단 하나라도 만족한다면 프록시 적용 대상이 된다.)
5. 프록시 생성 : 프록시 적용 대상이면 프록시를 생성하고 반환한 뒤(해당 프록시는 Advisor에 걸어둔다) 프록시를 스프링 빈으로 등록한다.
  (만약 프록시 적용 대상이 아니라면 해당 원본 객체를 반환해서 스프링 빈으로 등록한다.)

AspectJExpressionPointcut : AspectJ 포인트컷 표현식을 적용할 수 있다. (실무에서는 이거로만 사용된다) 